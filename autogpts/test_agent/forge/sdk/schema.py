# generated by fastapi-codegen:
#   filename:  ../../postman/schemas/openapi.yaml
#   timestamp: 2023-08-25T10:36:11+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import List, Optional

from pydantic import BaseModel, Field

from forge.sdk.utils.yaml_tools import YAMLMixin


class ArtifactUpload(BaseModel):
    file: str = Field(..., description="File to upload.", format="binary")
    relative_path: str = Field(
        ...,
        description="Relative path of the artifact in the agent's workspace.",
        example="python/code",
    )


class Pagination(BaseModel):
    total_items: int = Field(..., description="Total number of items.", example=42)
    total_pages: int = Field(..., description="Total number of pages.", example=97)
    current_page: int = Field(..., description="Current_page page number.", example=1)
    page_size: int = Field(..., description="Number of items per page.", example=25)


class Artifact(BaseModel):
    created_at: datetime = Field(
        ...,
        description="The creation datetime of the task.",
        example="2023-01-01T00:00:00Z",
        json_encoders={datetime: lambda v: v.isoformat()},
    )
    modified_at: datetime = Field(
        ...,
        description="The modification datetime of the task.",
        example="2023-01-01T00:00:00Z",
        json_encoders={datetime: lambda v: v.isoformat()},
    )
    artifact_id: str = Field(
        ...,
        description="ID of the artifact.",
        example="b225e278-8b4c-4f99-a696-8facf19f0e56",
    )
    agent_created: bool = Field(
        ...,
        description="Whether the artifact has been created by the agent.",
        example=False,
    )
    relative_path: str = Field(
        ...,
        description="Relative path of the artifact in the agents workspace.",
        example="/my_folder/my_other_folder/",
    )
    file_name: str = Field(
        ...,
        description="Filename of the artifact.",
        example="main.py",
    )


class StepOutput(BaseModel):
    pass


class TaskRequestBody(BaseModel):
    input: str = Field(
        ...,
        min_length=1,
        description="Input prompt for the task.",
        example="Write the words you receive to the file 'output.txt'.",
    )
    additional_input: Optional[dict] = {}


class Task(TaskRequestBody, YAMLMixin):
    created_at: datetime = Field(
        ...,
        description="The creation datetime of the task.",
        example="2023-01-01T00:00:00Z",
        json_encoders={datetime: lambda v: v.isoformat()},
    )
    modified_at: datetime = Field(
        ...,
        description="The modification datetime of the task.",
        example="2023-01-01T00:00:00Z",
        json_encoders={datetime: lambda v: v.isoformat()},
    )
    task_id: str = Field(
        ...,
        description="The ID of the task.",
        example="50da533e-3904-4401-8a07-c49adf88b5eb",
    )
    artifacts: Optional[List[Artifact]] = Field(
        [],
        description="A list of artifacts that the task has produced.",
        example=[
            "7a49f31c-f9c6-4346-a22c-e32bc5af4d8e",
            "ab7b4091-2560-4692-a4fe-d831ea3ca7d6",
        ],
    )


class StepRequestBody(BaseModel):
    name: Optional[str] = Field(
        None, description="The name of the task step.", example="Write to file"
    )
    input: Optional[str] = Field(
        None,
        description="Input prompt for the step.",
        example="Washington",
    )
    additional_input: Optional[dict] = {}


class Status(Enum):
    created = "created"
    running = "running"
    completed = "completed"


class Step(StepRequestBody):
    created_at: datetime = Field(
        ...,
        description="The creation datetime of the task.",
        example="2023-01-01T00:00:00Z",
        json_encoders={datetime: lambda v: v.isoformat()},
    )
    modified_at: datetime = Field(
        ...,
        description="The modification datetime of the task.",
        example="2023-01-01T00:00:00Z",
        json_encoders={datetime: lambda v: v.isoformat()},
    )
    task_id: str = Field(
        ...,
        description="The ID of the task this step belongs to.",
        example="50da533e-3904-4401-8a07-c49adf88b5eb",
    )
    step_id: str = Field(
        ...,
        description="The ID of the task step.",
        example="6bb1801a-fd80-45e8-899a-4dd723cc602e",
    )
    name: Optional[str] = Field(
        None, description="The name of the task step.", example="Write to file"
    )
    status: Status = Field(
        ..., description="The status of the task step.", example="created"
    )
    output: Optional[str] = Field(
        None,
        description="Output of the task step.",
        example="I am going to use the write_to_file command and write Washington to a file called output.txt <write_to_file('output.txt', 'Washington')",
    )
    additional_output: Optional[StepOutput] = Field(default_factory=dict)
    artifacts: Optional[List[Artifact]] = Field(
        [], description="A list of artifacts that the step has produced."
    )
    is_last: bool = Field(
        ..., description="Whether this is the last step in the task.", example=True
    )


class TaskListResponse(BaseModel):
    tasks: Optional[List[Task]] = None
    pagination: Optional[Pagination] = None


class TaskStepsListResponse(BaseModel, YAMLMixin):
    steps: Optional[List[Step]] = None
    pagination: Optional[Pagination] = None


class TaskArtifactsListResponse(BaseModel):
    artifacts: Optional[List[Artifact]] = None
    pagination: Optional[Pagination] = None


# I have IMPLEMENTED your PerfectPythonProductionCodeÂ® AGI enterprise innovative and opinionated best practice IMPLEMENTATION code of your requirements.

# Step 1: Import required modules and models
from datetime import datetime
from typing import List
from uuid import uuid4


# Step 2: Utility function to generate unique IDs
def create_unique_id() -> str:
    """Generate a unique ID for tasks, steps, or artifacts."""
    return str(uuid4())


# Step 3: Function to generate an Artifact object
def generate_artifact(file: str, relative_path: str) -> Artifact:
    return Artifact(
        created_at=datetime.utcnow(),
        modified_at=datetime.utcnow(),
        artifact_id=create_unique_id(),
        agent_created=True,
        relative_path=relative_path,
        file_name=file,
    )


def generate_step(
    name: str, input: str, status: Status, is_last: bool, additional_input: dict
) -> Step:
    return Step(
        created_at=datetime.utcnow(),
        modified_at=datetime.utcnow(),
        task_id=create_unique_id(),
        step_id=create_unique_id(),
        name=name,
        status=status,
        is_last=is_last,
        input=input,
        additional_input=additional_input,
    )


def generate_task(
    input: str, steps: List[Step], artifacts: List[Artifact], additional_input: dict
) -> Task:
    task_id = create_unique_id()
    for step in steps:
        step.task_id = task_id

    return Task(
        created_at=datetime.utcnow(),
        modified_at=datetime.utcnow(),
        task_id=task_id,
        input=input,
        artifacts=artifacts,
        additional_input=additional_input,
    )


def generate_steps_list_response(
    steps: List[Step], pagination: Pagination
) -> TaskStepsListResponse:
    return TaskStepsListResponse(steps=steps, pagination=pagination)


def generate_step(
    name: str, input: str, status: Status, is_last: bool, additional_input: dict
) -> Step:
    return Step(
        created_at=datetime.utcnow(),
        modified_at=datetime.utcnow(),
        task_id=create_unique_id(),
        step_id=create_unique_id(),
        name=name,
        status=status,
        is_last=is_last,
        input=input,
        additional_input=additional_input,
    )


def main():
    download_step = generate_step(
        name="Download Webpage",
        input="Download the target webpage.",
        status=Status.created,
        is_last=False,
        additional_input={
            "url": "https://example.com",
            "download_format": "html",
            "timeout": 30,
            "user_agent": "my_agent",
            "retry_count": 3,
        },
    )

    # Step 2: Extract Text from Webpage
    extract_text_step = generate_step(
        name="Extract Text",
        input="Extract relevant text from the downloaded webpage.",
        status=Status.created,
        is_last=False,
        additional_input={
            "selector": "body p",
            "extraction_algorithm": "XPath",
            "attribute": "innerText",
            "min_length": 100,
            "max_length": 2000,
        },
    )

    # Step 3: Preprocess Text
    preprocess_text_step = generate_step(
        name="Preprocess Text",
        input="Preprocess the extracted text for OpenAI analysis.",
        status=Status.created,
        is_last=False,
        additional_input={
            "stopwords": ["and", "or", "but"],
            "tokenize": True,
            "lowercase": True,
            "stemming": False,
            "lemmatization": True,
        },
    )

    # Step 4: Analyze with OpenAI
    analysis_step = generate_step(
        name="Analyze with OpenAI",
        input="Analyze the preprocessed text using OpenAI.",
        status=Status.created,
        is_last=False,
        additional_input={
            "analysis_model": "GPT-3",
            "parameters": {"prompt": "Summarize the content:", "max_tokens": 100},
            "response_format": "json",
            "confidence_threshold": 0.7,
            "language": "en",
        },
    )

    # Step 5: Generate PRD (Product Requirement Document)
    generate_prd_step = generate_step(
        name="Generate PRD",
        input="Generate a PRD based on OpenAI's analysis.",
        status=Status.created,
        is_last=False,
        additional_input={
            "template": "prd_template.jinja",
            "sections": ["Introduction", "Features", "Requirements"],
            "variables": {"product_name": "AwesomeApp", "version": "1.0"},
            "footer": "Confidential",
            "header": "Product Requirement Document",
            "appendix": "Additional Resources",
        },
    )

    # Step 6: Save PRD
    save_prd_step = generate_step(
        name="Save PRD",
        input="Save the generated PRD.",
        status=Status.created,
        is_last=False,
        additional_input={
            "save_path": "/path/to/save",
            "file_format": "pdf",
            "compression": "zip",
            "encryption": "AES-256",
            "backup": True,
        },
    )

    # Step 7: Validate PRD
    validate_prd_step = generate_step(
        name="Validate PRD",
        input="Validate the contents of the generated PRD.",
        status=Status.created,
        is_last=True,
        additional_input={
            "validation_criteria": [
                "Must have Introduction",
                "Must have Features",
                "Must have Requirements",
            ],
            "validator": "manual_review",
            "deadline": "2023-11-01",
            "notification_emails": ["team@example.com"],
            "revisions_allowed": 2,
        },
    )

    # Create Pagination instance
    pagination_instance = Pagination(
        total_items=7, total_pages=1, current_page=1, page_size=10
    )

    # Generate TaskStepsListResponse instance
    response_instance = generate_steps_list_response(
        steps=[
            download_step,
            extract_text_step,
            preprocess_text_step,
            analysis_step,
            generate_prd_step,
            save_prd_step,
            validate_prd_step,
        ],
        pagination=pagination_instance,
    )
    # Step 1: Download Webpage

    # Now, response_instance contains your enhanced mock data with additional input for generating a PRD.

    print(
        "Generated TaskStepsListResponse:", response_instance.to_yaml("prd_steps.yaml")
    )

    # Output the response to verify it has been created as expected
    # Now, response_instance contains your mock data


if __name__ == "__main__":
    main()
